#!/usr/bin/env make
#
# Makefile.config - Calc configuration and compile configuration values
#
# Copyright (C) 2023  Landon Curt Noll
#
# Suggestion: Read the HOWTO.INSTALL file.
#
# Calc is open software; you can redistribute it and/or modify it under
# the terms of version 2.1 of the GNU Lesser General Public License
# as published by the Free Software Foundation.
#
# Calc is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General
# Public License for more details.
#
# A copy of version 2.1 of the GNU Lesser General Public License is
# distributed with calc under the filename COPYING-LGPL.  You should have
# received a copy with calc; if not, write to Free Software Foundation, Inc.
# 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
#
# This calculator first developed by David I. Bell with help/mods from others.
#
# chongo <was here> /\oo/\	http://www.isthe.com/chongo/
# Share and enjoy!  :-)		http://www.isthe.com/chongo/tech/comp/calc/


# SUGGESTION: Instead of modifying this file, consider adding
#	      statements to modify, replace or append Makefile
#	      variables in the Makefile.local file.


# We do not support parallel make of calc.  We have found most
# parallel make systems do not get the rule dependency order
# correct, resulting in a failed attempt to compile calc.
#
# If you believe you have a way to get a parallel make of calc
# to work, consider submitting a pull request with a
# proposed change.
#
.NOTPARALLEL:


##############################
# Set the target information #
##############################

# NOTE: You can force a target value by defining target as in:
#
#	make ...__optional_arguments_... target=value
#
# Try uname -s if the target was not already set on the make command line
#
ifeq ($(target),)
target=$(shell uname -s 2>/dev/null)
endif	# ($(target),)
ifeq ($(arch),)
arch=$(shell uname -p 2>/dev/null)
endif	# ($(arch),)
ifeq ($(hardware),)
hardware=$(shell uname -m 2>/dev/null)
endif	# ($(hardware),)
ifeq ($(OSNAME),)
OSNAME=$(shell uname -o 2>/dev/null)
endif	# ($(OSNAME),)


###################################
# Set the shell used in Makefiles #
###################################

# The shell used by this Makefile
#
# On some systems, /bin/sh is a rather reduced shell with
# deprecated behavior.
#
# If your system has a up to date, bash shell, then
# you may wish to use:
#
#	SHELL= bash
#
# On some systems such as macOS, the bash shell is very
# far behind to the point where is cannot be depended on.
# On such systems, the sh may be a much better alternative
# shell for this Makefile to use:
#
#	SHELL= sh
#
SHELL= bash
#SHELL= sh

# Darwin shell default
#
ifeq ($(target),Darwin)
SHELL:= /bin/sh
endif	# ($(target),Darwin)

# If you are using Cygwin with MinGW64 packages
# then we will also need to use the Cygwin runtime enviroment
# and the calc Cygwin make target.
#
ifeq ($(OSNAME),Cygwin)
target:= Cygwin
endif	# ($(OSNAME),Cygwin)

# MSYS2 (MSYS) is a fork of Cygwin
#
ifeq ($(OSNAME),Msys)
target:= Cygwin
endif	# ($(OSNAME),Msys)


##############################################################################
#-=-=-=-=-=-=-=-=- You may want to change some values below -=-=-=-=-=-=-=-=-#
##############################################################################

# PREFIX - Top level location for calc
#
# The PREFIX is often prepended to paths within calc and calc Makefiles.
#
# Starting with calc v2.13.0.1, nearly all Makefile places that used
# /usr/local now use ${PREFIX}.  An exception is the olduninstall rule
# and, of course, this section. :-)
#
# NOTE: The ${PREFIX} is not the same as ${T}.  The ${T} specifies
#	a top level directory under which calc installs things.
#	While usually ${T} is empty, it can be specific path
#	as if calc where "chrooted" during an install.
#	The ${PREFIX} value, during install, is a path between
#	the top level ${T} install directory and the object
#	such as an include file.
#
# NOTE: See also, ${T}, below.
#
# There are some paths that do NOT call under ${PREFIX}, such as
# ${CALCPATH}, that include paths not under ${PREFIX}, but those
# too are exceptions to this general rule.
#
# When in doubt, try:
#
#	PREFIX= /usr/local
#
PREFIX= /usr/local
#PREFIX= /usr
#PREFIX= /usr/global

# CCBAN is given to ${CC} in order to control if banned.h is in effect.
#
# The banned.h attempts to ban the use of certain dangerous functions
# that, if improperly used, could compromise the computational integrity
# if calculations.
#
# In the case of calc, we are motivated in part by the desire for calc
# to correctly calculate: even during extremely long calculations.
#
# If UNBAN is NOT defined, then calling certain functions
# will result in a call to a non-existent function (link error).
#
# While we do NOT encourage defining UNBAN, there may be
# a system / compiler environment where re-defining a
# function may lead to a fatal compiler complication.
# If that happens, consider compiling as:
#
#	make clobber all chk CCBAN=-DUNBAN
#
# as see if this is a work-a-round.
#
# If YOU discover a need for the -DUNBAN work-a-round, PLEASE tell us!
# Please send us a bug report.  See the file:
#
#	BUGS
#
# or the URL:
#
#	http://www.isthe.com/chongo/tech/comp/calc/calc-bugrept.html
#
# for how to send us such a bug report.
#
CCBAN= -UUNBAN
#CCBAN= -DUNBAN

# Determine the type of terminal controls that you want to use
#
#	value		  meaning
#	--------	  -------
#	(nothing)	  let the Makefile guess at what you need
#	-DUSE_TERMIOS	  use struct termios from <termios.h>
#	-DUSE_TERMIO	  use struct termios from <termio.h>
#	-DUSE_SGTTY	  use struct sgttyb from <sys/ioctl.h>
#	-DUSE_NOTHING	  Windows system, don't use any of them
#
# If in doubt, leave TERMCONTROL empty.
#
TERMCONTROL=
#TERMCONTROL= -DUSE_TERMIOS
#TERMCONTROL= -DUSE_TERMIO
#TERMCONTROL= -DUSE_SGTTY

# If your system does not have a vsnprintf() function, you could be in trouble.
#
#	vsnprintf(string, size, format, ap)
#
# This function works like spnrintf except that the 4th arg is a va_list
# strarg (or varargs) list.  Some old systems do not have vsnprintf().
# If you do not have vsnprintf(), then calc will try snprintf() and hope
# for the best.
#
# A similar problem occurs if your system does not have a vsnprintf()
# function.  This function is like the vsnprintf() function except that
# there is an extra second argument that controls the maximum size
# string that is produced.
#
# If HAVE_VSNPRINTF is empty, this Makefile will run the have_stdvs.c and/or
# have_varvs.c program to determine if vsnprintf() is supported.  If
# HAVE_VSNPRINTF is set to -DDONT_HAVE_VSNPRINTF then calc will hope that
# snprintf() will work.
#
# If in doubt, leave HAVE_VSNPRINTF empty.
#
HAVE_VSNPRINTF=
#HAVE_VSNPRINTF= -DDONT_HAVE_VSNPRINTF

# Determine the byte order of your machine
#
#    Big Endian:	Amdahl, 68k, Pyramid, Mips, Sparc, ...
#    Little Endian:	Vax, 32k, Spim (Dec Mips), i386, i486, ...
#
# If in doubt, leave CALC_BYTE_ORDER empty.  This Makefile will attempt to
# use BYTE_ORDER in <machine/endian.h> or it will attempt to run
# the endian program.  If you get syntax errors when you compile,
# try forcing the value to be -DBIG_ENDIAN and run the calc regression
# tests. (see the README.FIRST file) If the calc regression tests fail, do
# a make clobber and try -DCALC_LITTLE_ENDIAN.   If that fails, ask a wizard
# for help.
#
CALC_BYTE_ORDER=
#CALC_BYTE_ORDER= -DBIG_ENDIAN
#CALC_BYTE_ORDER= -DLITTLE_ENDIAN

# Determine the number of bits in a byte
#
# If in doubt, leave CALC_CHARBIT empty.  This Makefile will run
# the charbits program to determine the length.
#
# In order to avoid make brain damage in some systems, we avoid placing
# a space after the ='s below.
#
CALC_CHARBIT=
#CALC_CHARBIT= 8

# Determine the number of bits in a long
#
# If in doubt, leave LONG_BITS empty.  This Makefile will run
# the longbits program to determine the length.
#
# In order to avoid make brain damage in some systems, we avoid placing
# a space after the ='s below.
#
LONG_BITS=
#LONG_BITS= 32
#LONG_BITS= 64

# Determine if we have the ANSI C fgetpos and fsetpos alternate interface
# to the ftell() and fseek() (with whence set to SEEK_SET) functions.
#
# If HAVE_FGETSETPOS is empty, this Makefile will run the have_fpos program
# to determine if there is are fgetpos and fsetpos functions.  If HAVE_FGETSETPOS
# is set to -DHAVE_NO_FGETSETPOS, then calc will use ftell() and fseek().
#
# If in doubt, leave HAVE_FGETSETPOS empty and this Makefile will figure it out.
#
HAVE_FGETSETPOS=
#HAVE_FGETSETPOS= -DHAVE_NO_FGETSETPOS

# Determine if we have an __pos element of a file position (fpos_t) structure.
#
# If HAVE_FPOS_POS is empty, this Makefile will run the have_fpos_pos program
# to determine if fpos_t has a __pos structure element.  If HAVE_FPOS_POS
# is set to -DHAVE_NO_FPOS_POS, then calc assume there is no __pos element.
#
# If in doubt, leave HAVE_FPOS_POS empty and this Makefile will figure it out.
#
HAVE_FPOS_POS=
#HAVE_FPOS_POS= -DHAVE_NO_FPOS_POS

# Determine the size of the __pos element in fpos_t, if it exists.
#
# If FPOS_POS_BITS is empty, then the Makefile will determine the size of
# the file position value of the __pos element.
#
# If there is no __pos element in fpos_t (say because fpos_t is a scalar),
# leave FPOS_POS_BITS blank.
#
# If in doubt, leave FPOS_POS_BITS empty and this Makefile will figure it out.
#
FPOS_POS_BITS=
#FPOS_POS_BITS= 32
#FPOS_POS_BITS= 64

# Determine the size of a file position value.
#
# If FPOS_BITS is empty, then the Makefile will determine the size of
# the file position value.
#
# If in doubt, leave FPOS_BITS empty and this Makefile will figure it out.
#
FPOS_BITS=
#FPOS_BITS= 32
#FPOS_BITS= 64

# Determine the size of the off_t file offset element
#
# If OFF_T_BITS is empty, then the Makefile will determine the size of
# the file offset value.
#
# If in doubt, leave OFF_T_BITS empty and this Makefile will figure it out.
#
OFF_T_BITS=
#OFF_T_BITS= 32
#OFF_T_BITS= 64

# Determine the size of the dev_t device value
#
# If DEV_BITS is empty, then the Makefile will determine the size of
# the dev_t device value
#
# If in doubt, leave DEV_BITS empty and this Makefile will figure it out.
#
DEV_BITS=
#DEV_BITS= 16
#DEV_BITS= 32
#DEV_BITS= 64

# Determine the size of the ino_t device value
#
# If INODE_BITS is empty, then the Makefile will determine the size of
# the ino_t inode value
#
# If in doubt, leave INODE_BITS empty and this Makefile will figure it out.
#
INODE_BITS=
#INODE_BITS= 16
#INODE_BITS= 32
#INODE_BITS= 64

# Determine if we have an off_t which one can perform arithmetic operations,
# assignments and comparisons.  On some systems off_t is some sort of union
# or struct.
#
# If HAVE_OFFSCL is empty, this Makefile will run the have_offscl program
# to determine if off_t is a scalar.  If HAVE_OFFSCL is set to the value
# -DOFF_T_NON_SCALAR when calc will assume that off_t some sort of
# union or struct.
#
# If in doubt, leave HAVE_OFFSCL empty and this Makefile will figure it out.
#
HAVE_OFFSCL=
#HAVE_OFFSCL= -DOFF_T_NON_SCALAR

# Determine if we have an fpos_t which one can perform arithmetic operations,
# assignments and comparisons.  On some systems fpos_t is some sort of union
# or struct.  Some systems do not have an fpos_t and long is as a file
# offset instead.
#
# If HAVE_POSSCL is empty, this Makefile will run the have_offscl program
# to determine if off_t is a scalar, or if there is no off_t and long
# (a scalar) should be used instead.  If HAVE_POSSCL is set to the value
# -DFILEPOS_NON_SCALAR when calc will assume that fpos_t exists and is
# some sort of union or struct.
#
# If in doubt, leave HAVE_POSSCL empty and this Makefile will figure it out.
#
HAVE_POSSCL=
#HAVE_POSSCL= -DFILEPOS_NON_SCALAR

# Determine if we have ANSI C const.
#
# If HAVE_CONST is empty, this Makefile will run the have_const program
# to determine if const is supported.  If HAVE_CONST is set to -DHAVE_NO_CONST,
# then calc will not use const.
#
# If in doubt, leave HAVE_CONST empty and this Makefile will figure it out.
#
HAVE_CONST=
#HAVE_CONST= -DHAVE_NO_CONST

# Determine if we have uid_t
#
# If HAVE_UID_T is empty, this Makefile will run the have_uid_t program
# to determine if uid_t is supported.  If HAVE_UID_T is set to -DHAVE_NO_UID_T,
# then calc will treat uid_t as an unsigned short.  This only matters if
# $HOME is not set and calc must look up the home directory in /etc/passwd.
#
# If in doubt, leave HAVE_UID_T empty and this Makefile will figure it out.
#
HAVE_UID_T=
#HAVE_UID_T= -DHAVE_NO_UID_T

# Determine if we have a non-NULL user environment external:
#
#	extern char **environ;	/* user environment */
#
# If HAVE_ENVIRON is empty, this Makefile will run the have_environ program
# to determine if environ exists and is non-NULL.  If HAVE_ENVIRON is set
# to -DHAVE_NO_ENVIRON, then calc will assume there is no external environ
# symbol.
#
# If in doubt, leave HAVE_ENVIRON empty and this Makefile will figure it out.
#
HAVE_ENVIRON=
#HAVE_ENVIRON= -DHAVE_NO_ENVIRON

# Determine if we have the arc4random_buf() function
#
# If HAVE_ARC4RANDOM is empty, this Makefile will run the have_arc4random
# program to determine if arc4random_buf() function exists.  If
# HAVE_ARC4RANDOM is set to -DHAVE_NO_ARC4RANDOM, then calc will assume
# there is no arc4random_buf() function.
#
# If in doubt, leave HAVE_ARC4RANDOM empty and this Makefile will figure it out.
#
HAVE_ARC4RANDOM=
#HAVE_ARC4RANDOM= -DHAVE_NO_ARC4RANDOM

# Determine if we have memcpy(), memset() and strchr()
#
# If HAVE_NEWSTR is empty, this Makefile will run the have_newstr program
# to determine if memcpy(), memset() and strchr() are supported.  If
# HAVE_NEWSTR is set to -DHAVE_NO_NEWSTR, then calc will use bcopy() instead
# of memcpy(), use bfill() instead of memset(), and use index() instead of
# strchr().
#
# If in doubt, leave HAVE_NEWSTR empty and this Makefile will figure it out.
#
HAVE_NEWSTR=
#HAVE_NEWSTR= -DHAVE_NO_NEWSTR

# Determine if we have memmove()
#
# If HAVE_MEMMOVE is empty, this Makefile will run the have_memmv program
# to determine if memmove() is supported.  If HAVE_MEMMOVE is set to
# -DHAVE_NO_MEMMOVE, then calc will use internal functions to simulate
# the memory move function that does correct overlapping memory moves.
#
# If in doubt, leave HAVE_MEMMOVE empty and this Makefile will figure it out.
#
HAVE_MEMMOVE=
#HAVE_MEMMOVE= -DHAVE_NO_MEMMOVE

# Determine if we have ustat()
#
# If HAVE_USTAT is empty, this Makefile will run the have_ustat program
# to determine if ustat() is supported.  If HAVE_USTAT is set to
# -DHAVE_NO_USTAT, then calc will use internal functions to simulate
# the ustat() function that gets file system statistics.
#
# If in doubt, leave HAVE_USTAT empty and this Makefile will figure it out.
#
HAVE_USTAT=
#HAVE_USTAT= -DHAVE_NO_USTAT

# Determine if we have statfs()
#
# If HAVE_STATFS is empty, this Makefile will run the have_statfs program
# to determine if statfs() is supported.  If HAVE_STATFS is set to
# -DHAVE_NO_STATFS, then calc will use internal functions to simulate
# the statfs() function that gets file system statistics.
#
# If in doubt, leave HAVE_STATFS empty and this Makefile will figure it out.
#
HAVE_STATFS=
#HAVE_STATFS= -DHAVE_NO_STATFS

# Determine if we have the <sys/vfs.h> include file.
#
#    HAVE_SYS_VFS_H=		let the Makefile look for the include file
#    HAVE_SYS_VFS_H= YES	assume that the include file exists
#    HAVE_SYS_VFS_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_SYS_VFS_H empty.
#
HAVE_SYS_VFS_H=
#HAVE_SYS_VFS_H= YES
#HAVE_SYS_VFS_H= NO

# Determine if we have the <sys/param.h> include file.
#
#    HAVE_SYS_PARAM_H=		let the Makefile look for the include file
#    HAVE_SYS_PARAM_H= YES	assume that the include file exists
#    HAVE_SYS_PARAM_H= NO	assume that the include file does not exist
#
# When in doubt, leave HAVE_SYS_PARAM_H empty.
#
HAVE_SYS_PARAM_H=
#HAVE_SYS_PARAM_H= YES
#HAVE_SYS_PARAM_H= NO

# Determine if we have the <sys/mount.h> include file.
#
#    HAVE_SYS_MOUNT_H=		let the Makefile look for the include file
#    HAVE_SYS_MOUNT_H= YES	assume that the include file exists
#    HAVE_SYS_MOUNT_H= NO	assume that the include file does not exist
#
# When in doubt, leave HAVE_SYS_MOUNT_H empty.
#
HAVE_SYS_MOUNT_H=
#HAVE_SYS_MOUNT_H= YES
#HAVE_SYS_MOUNT_H= NO

# Determine if we have getsid()
#
# If HAVE_GETSID is empty, this Makefile will run the have_getsid program
# to determine if getsid() is supported.  If HAVE_GETSID is set to
# -DHAVE_NO_GETSID, then calc will use internal functions to simulate
# the getsid() function that gets session ID.
#
# If in doubt, leave HAVE_GETSID empty and this Makefile will figure it out.
#
HAVE_GETSID=
#HAVE_GETSID= -DHAVE_NO_GETSID

# Determine if we have getpgid()
#
# If HAVE_GETPGID is empty, this Makefile will run the have_getpgid program
# to determine if getpgid() is supported.  If HAVE_GETPGID is set to
# -DHAVE_NO_GETPGID, then calc will use internal functions to simulate
# the getpgid() function that sets the process group ID.
#
# If in doubt, leave HAVE_GETPGID empty and this Makefile will figure it out.
#
HAVE_GETPGID=
#HAVE_GETPGID= -DHAVE_NO_GETPGID

# Determine if we have clock_gettime()
#
# If HAVE_GETTIME is empty, this Makefile will run the have_gettime program
# to determine if clock_gettime() is supported.  If HAVE_GETTIME is set to
# -DHAVE_NO_GETTIME, then calc will use internal functions to simulate
# the clock_gettime() function.
#
# If in doubt, leave HAVE_GETTIME empty and this Makefile will figure it out.
#
HAVE_GETTIME=
#HAVE_GETTIME= -DHAVE_NO_GETTIME

# Determine if we have getprid()
#
# If HAVE_GETPRID is empty, this Makefile will run the have_getprid program
# to determine if getprid() is supported.  If HAVE_GETPRID is set to
# -DHAVE_NO_GETPRID, then calc will use internal functions to simulate
# the getprid() function.
#
# If in doubt, leave HAVE_GETPRID empty and this Makefile will figure it out.
#
HAVE_GETPRID=
#HAVE_GETPRID= -DHAVE_NO_GETPRID

# Determine if we have the /dev/urandom
#
#    HAVE_URANDOM_H=		let the Makefile look for /dev/urandom
#    HAVE_URANDOM_H= YES	assume that /dev/urandom exists
#    HAVE_URANDOM_H= NO		assume that /dev/urandom does not exist
#
# When in doubt, leave HAVE_URANDOM_H empty.
#
HAVE_URANDOM_H=
#HAVE_URANDOM_H= YES
#HAVE_URANDOM_H= NO

# Determine if we have getrusage()
#
# If HAVE_GETRUSAGE is empty, this Makefile will run the have_rusage program
# to determine if getrusage() is supported.  If HAVE_GETRUSAGE is set to
# -DHAVE_NO_GETRUSAGE, then calc will use internal functions to simulate
# the getrusage() function.
#
# If in doubt, leave HAVE_GETRUSAGE empty and this Makefile will figure it out.
#
HAVE_GETRUSAGE=
#HAVE_GETRUSAGE= -DHAVE_NO_GETRUSAGE

# Determine if we have strdup()
#
# If HAVE_STRDUP is empty, this Makefile will run the have_strdup program
# to determine if strdup() is supported.  If HAVE_STRDUP is set to
# -DHAVE_NO_STRDUP, then calc will use internal functions to simulate
# the strdup() function.
#
# If in doubt, leave HAVE_STRDUP empty and this Makefile will figure it out.
#
HAVE_STRDUP=
#HAVE_STRDUP= -DHAVE_NO_STRDUP

# Some architectures such as Sparc do not allow one to access 32 bit values
# that are not aligned on a 32 bit boundary.
#
# The Dec Alpha running OSF/1 will produce alignment error messages when
# align32.c tries to figure out if alignment is needed.  Use the
# ALIGN32= -DMUST_ALIGN32 to force alignment and avoid such error messages.
#
# ALIGN32=		     let align32.c figure out if alignment is needed
# ALIGN32= -DMUST_ALIGN32    force 32 bit alignment
# ALIGN32= -UMUST_ALIGN32    allow non-alignment of 32 bit accesses
#
# When in doubt, be safe and pick ALIGN32=-DMUST_ALIGN32.
#
ALIGN32=
#ALIGN32= -DMUST_ALIGN32
#ALIGN32= -UMUST_ALIGN32

# Determine if we have the <stdlib.h> include file.
#
#    HAVE_STDLIB_H=		let the Makefile look for the include file
#    HAVE_STDLIB_H= YES		assume that the include file exists
#    HAVE_STDLIB_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_STDLIB_H empty.
#
HAVE_STDLIB_H=
#HAVE_STDLIB_H= YES
#HAVE_STDLIB_H= NO

# Determine if we have the <string.h> include file.
#
#    HAVE_STRING_H=		let the Makefile look for the include file
#    HAVE_STRING_H= YES		assume that the include file exists
#    HAVE_STRING_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_STRING_H empty.
#
HAVE_STRING_H=
#HAVE_STRING_H= YES
#HAVE_STRING_H= NO

# Determine if we have the <times.h> include file.
#
#    HAVE_TIMES_H=		let the Makefile look for the include file
#    HAVE_TIMES_H= YES		assume that the include file exists
#    HAVE_TIMES_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_TIMES_H empty.
#
HAVE_TIMES_H=
#HAVE_TIMES_H= YES
#HAVE_TIMES_H= NO

# Determine if we have the <sys/times.h> include file.
#
#    HAVE_SYS_TIMES_H=		let the Makefile look for the include file
#    HAVE_SYS_TIMES_H= YES	assume that the include file exists
#    HAVE_SYS_TIMES_H= NO	assume that the include file does not exist
#
# When in doubt, leave HAVE_SYS_TIMES_H empty.
#
HAVE_SYS_TIMES_H=
#HAVE_SYS_TIMES_H= YES
#HAVE_SYS_TIMES_H= NO

# Determine if we have the <time.h> include file.
#
#    HAVE_TIME_H=		let the Makefile look for the include file
#    HAVE_TIME_H= YES		assume that the include file exists
#    HAVE_TIME_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_TIME_H empty.
#
HAVE_TIME_H=
#HAVE_TIME_H= YES
#HAVE_TIME_H= NO

# Determine if we have the <sys/time.h> include file.
#
#    HAVE_SYS_TIME_H=		let the Makefile look for the include file
#    HAVE_SYS_TIME_H= YES	assume that the include file exists
#    HAVE_SYS_TIME_H= NO	assume that the include file does not exist
#
# When in doubt, leave HAVE_SYS_TIME_H empty.
#
HAVE_SYS_TIME_H=
#HAVE_SYS_TIME_H= YES
#HAVE_SYS_TIME_H= NO

# Determine if we have the <unistd.h> include file.
#
#    HAVE_UNISTD_H=		let the Makefile look for the include file
#    HAVE_UNISTD_H= YES		assume that the include file exists
#    HAVE_UNISTD_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_UNISTD_H empty.
#
HAVE_UNISTD_H=
#HAVE_UNISTD_H= YES
#HAVE_UNISTD_H= NO

# Determine if we have the <limits.h> include file.
#
#    HAVE_LIMITS_H=		let the Makefile look for the include file
#    HAVE_LIMITS_H= YES		assume that the include file exists
#    HAVE_LIMITS_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_LIMITS_H empty.
#
HAVE_LIMITS_H=
#HAVE_LIMITS_H= YES
#HAVE_LIMITS_H= NO

# Determine if we have the <stdbool.h> include file.
#
#    HAVE_STDBOOL_H=		let the Makefile look for the include file
#    HAVE_STDBOOL_H= YES	assume that the include file exists
#    HAVE_STDBOOL_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_STDBOOL_H empty.
#
HAVE_STDBOOL_H=
#HAVE_STDBOOL_H= YES
#HAVE_STDBOOL_H= NO

# Determine if we have the <stdint.h> include file.
#
#    HAVE_STDINT_H=		let the Makefile look for the include file
#    HAVE_STDINT_H= YES		assume that the include file exists
#    HAVE_STDINT_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_STDINT_H empty.
#
HAVE_STDINT_H=
#HAVE_STDINT_H= YES
#HAVE_STDINT_H= NO

# Determine if we have the <inttypes.h> include file.
#
#    HAVE_INTTYPES_H=		let the Makefile look for the include file
#    HAVE_INTTYPES_H= YES		assume that the include file exists
#    HAVE_INTTYPES_H= NO		assume that the include file does not exist
#
# When in doubt, leave HAVE_INTTYPES_H empty.
#
HAVE_INTTYPES_H=
#HAVE_INTTYPES_H= YES
#HAVE_INTTYPES_H= NO

# Determine if our compiler allows the unused attribute
#
# If HAVE_UNUSED is empty, this Makefile will run the have_unused program
# to determine if the unused attribute is supported.  If HAVE_UNUSED is set to
# -DHAVE_NO_UNUSED, then the unused attribute will not be used.
#
# If in doubt, leave HAVE_UNUSED empty and this Makefile will figure it out.
#
HAVE_UNUSED=
#HAVE_UNUSED= -DHAVE_NO_UNUSED

# Determine if we allow use of "#pragma GCC poison func_name"
#
# If HAVE_PRAGMA_GCC_POSION is empty, then Makefile will run the
# have_bprag program to determine if the "#pragma GCC poison func_name"
# is supported.  If HAVE_PRAGMA_GCC_POSION is set to
# -DHAVE_NO_PRAGMA_GCC_POSION. then the "#pragma GCC poison func_name"
# is not used.
#
# If in doubt, leave HAVE_PRAGMA_GCC_POSION empty and this Makefile
# will figure it out.
#
HAVE_PRAGMA_GCC_POSION=
#HAVE_PRAGMA_GCC_POSION= -DHAVE_NO_PRAGMA_GCC_POSION

# Determine if we have strlcpy()
#
# If HAVE_STRLCPY is empty, this Makefile will run the have_strlcpy program
# to determine if strlcpy() is supported.  If HAVE_STRLCPY is set to
# -DHAVE_NO_STRLCPY, then calc will use internal functions to simulate
# the strlcpy() function.
#
# If in doubt, leave HAVE_STRLCPY empty and this Makefile will figure it out.
#
HAVE_STRLCPY=
#HAVE_STRLCPY= -DHAVE_NO_STRLCPY

# Determine if we have strlcat()
#
# If HAVE_STRLCAT is empty, this Makefile will run the have_strlcat program
# to determine if strlcat() is supported.  If HAVE_STRLCAT is set to
# -DHAVE_NO_STRLCAT, then calc will use internal functions to simulate
# the strlcat() function.
#
# If in doubt, leave HAVE_STRLCAT empty and this Makefile will figure it out.
#
HAVE_STRLCAT=
#HAVE_STRLCAT= -DHAVE_NO_STRLCAT

# System include files
#
# ${INCDIR}		where the system include (.h) files are kept
#
# If in doubt, for non-macOS hosts set:
#
#	INCDIR= /usr/include
#
# However, if you are on macOS then set:
#
#	INCDIR= ${PREFIX}/include
#
ifeq ($(target),Darwin)

# determine default INCDIR for macOS
#
ifeq ($(arch),powerpc)
# Default location for old systems such as Mac OS X 10.6 Snow Leopard
INCDIR= /usr/include
else	# ($(arch),powerpc)
# Modern macOS such as macOS 10.11.6 and later
INCDIR= $(shell xcrun --sdk macosx --show-sdk-path 2>/dev/null)/usr/include
endif	# ($(arch),powerpc)

# default INCDIR for non-macOS
#
else	# ($(target),Darwin)

INCDIR= /usr/include
#INCDIR= ${PREFIX}/include
#INCDIR= /dev/env/DJDIR/include

endif	# ($(target),Darwin)

# Where to install calc related things
#
# ${BINDIR}		where to install calc binary files
# ${LIBDIR}		where calc link library (*.a) files are installed
# ${CALC_SHAREDIR}	where to install calc help, .cal, startup, config files
# ${CALC_INCDIR}	where the calc include files are installed
#
# NOTE: The install rule prepends installation paths with ${T}, which
#	by default is empty.  If ${T} is non-empty, then installation
#	locations will be relative to the ${T} directory.
#
# NOTE: If you change LIBDIR to a non-standard location, you will need
#	to make changes to your execution environment so that executables
#	will search LIBDIR when they are resolving dynamic shared libraries.
#
#	On OS X, this means you need to export $DYLD_LIBRARY_PATH
#	to include the LIBDIR path in the value.
#
#	On Linux and BSD, this means you need to export $LD_LIBRARY_PATH
#	to include the LIBDIR path in the value.
#
#	You might be better off not changing LIBDIR in the first place.
#
# If in doubt, for non-macOS hosts set:
#
#	BINDIR= /usr/bin
#	LIBDIR= /usr/lib
#	CALC_SHAREDIR= /usr/share/calc
#	CALC_INCDIR= /usr/include/calc
#
# Or if you prefer everything under /usr/local:
#
#	BINDIR= /usr/local/bin
#	LIBDIR= /usr/local/lib
#	CALC_SHAREDIR= /usr/local/share/calc
#	CALC_INCDIR= /usr/local/include/calc
#
# However, if you are on macOS then set:
#
#	BINDIR= ${PREFIX}/bin
#	LIBDIR= ${PREFIX}/lib
#	CALC_SHAREDIR= ${PREFIX}/share/calc
#	CALC_INCDIR= ${PREFIX}/include/calc
#
#	NOTE: Starting with macOS El Capitan OS X 10.11, root by default
#	      could not mkdir under system locations, so macOS must now
#	      use the ${PREFIX} tree.

# defaults for macOS
ifeq ($(target),Darwin)
BINDIR= ${PREFIX}/bin
LIBDIR= ${PREFIX}/lib
CALC_SHAREDIR= ${PREFIX}/share/calc

# defaults for non-macOS
else	# ($(target),Darwin)
# default BINDIR for non-macOS
BINDIR= /usr/bin
#BINDIR= ${PREFIX}/bin
#BINDIR= /dev/env/DJDIR/bin
# default LIBDIR for non-macOS
LIBDIR= /usr/lib
#LIBDIR= ${PREFIX}/lib
#LIBDIR= /dev/env/DJDIR/lib
# default CALC_SHAREDIR for non-macOS
CALC_SHAREDIR= /usr/share/calc
#CALC_SHAREDIR= ${PREFIX}/lib/calc
#CALC_SHAREDIR= /dev/env/DJDIR/share/calc
endif	# ($(target),Darwin)

# NOTE: Do not set CALC_INCDIR to /usr/include or ${PREFIX}/include!!!
#	Always be sure that the CALC_INCDIR path ends in /calc to avoid
#	conflicts with system or other application include files!!!
#
#CALC_INCDIR= ${PREFIX}/include/calc
#CALC_INCDIR= /dev/env/DJDIR/include/calc
CALC_INCDIR= ${INCDIR}/calc

# By default, these values are based CALC_SHAREDIR, INCDIR, BINDIR
# ---------------------------------------------------------------
# ${HELPDIR}		where the help directory is installed
# ${CUSTOMCALDIR}	where custom *.cal files are installed
# ${CUSTOMHELPDIR}	where custom help files are installed
# ${CUSTOMINCDIR}	where custom .h files are installed
# ${SCRIPTDIR}		where calc shell scripts are installed
#
# NOTE: The install rule prepends installation paths with ${T}, which
#	by default is empty.  If ${T} is non-empty, then installation
#	locations will be relative to the ${T} directory.
#
# If in doubt, set:
#
#	HELPDIR= ${CALC_SHAREDIR}/help
#	CALC_INCDIR= ${INCDIR}/calc
#	CUSTOMCALDIR= ${CALC_SHAREDIR}/custom
#	CUSTOMHELPDIR= ${CALC_SHAREDIR}/custhelp
#	CUSTOMINCDIR= ${CALC_INCDIR}/custom
#	SCRIPTDIR= ${BINDIR}/cscript
#
HELPDIR= ${CALC_SHAREDIR}/help
CUSTOMCALDIR= ${CALC_SHAREDIR}/custom
CUSTOMHELPDIR= ${CALC_SHAREDIR}/custhelp
CUSTOMINCDIR= ${CALC_INCDIR}/custom
SCRIPTDIR= ${BINDIR}/cscript

# T - top level directory under which calc will be installed
#
# The calc install is performed under ${T}, the calc build is
# performed under /.  The purpose for ${T} is to allow someone
# to install calc somewhere other than into the system area.
#
# For example, if:
#
#     BINDIR= /usr/bin
#     LIBDIR= /usr/lib
#     CALC_SHAREDIR= /usr/share/calc
#
# and if:
#
#     T= /var/tmp/testing
#
# Then the installation locations will be:
#
#     calc binary files:	/var/tmp/testing/usr/bin
#     calc link library:	/var/tmp/testing/usr/lib
#     calc help, .cal ...:	/var/tmp/testing/usr/share/calc
#     ... etc ...               /var/tmp/testing/...
#
# If ${T} is empty, calc is installed under /, which is the same
# top of tree for which it was built.  If ${T} is non-empty, then
# calc is installed under ${T}, as if one had to chroot under
# ${T} for calc to operate.
#
# NOTE: The ${PREFIX} is not the same as ${T}.  The ${T} specifies
#	a top level directory under which calc installs things.
#	While usually ${T} is empty, it can be specific path
#	as if calc where "chrooted" during an install.
#	The ${PREFIX} value, during install, is a path between
#	the top level ${T} install directory and the object
#	such as an include file.
#
#	See ${PREFIX} above.
#
# If in doubt, use T=
#
T=

# where man section 1 pages are installed
#
# Use MANDIR= to disable installation of the calc man (source) page.
#
# NOTE: man pages not installed by macOS must go under,
# (according to MANPATH as found in /private/etc/man.conf):
#
#	MANDIR= ${PREFIX}/share/man/man1
#
#MANDIR=
#MANDIR= ${PREFIX}/man/man1
#MANDIR= /usr/man/man1
#
ifeq ($(target),Darwin)
MANDIR= ${PREFIX}/share/man/man1
else	# ($(target),Darwin)
MANDIR= /usr/share/man/man1
endif	# ($(target),Darwin)
#MANDIR= /dev/env/DJDIR/man/man1
#MANDIR= /usr/man/u_man/man1
#MANDIR= /usr/contrib/man/man1

# where cat (formatted man) pages are installed
#
# Use CATDIR= to disable installation of the calc cat (formatted) page.
#
CATDIR=
#CATDIR= ${PREFIX}/man/cat1
#CATDIR= ${PREFIX}/catman/cat1
#CATDIR= /usr/man/cat1
#CATDIR= /usr/share/man/cat1
#CATDIR= /dev/env/DJDIR/man/cat1
#CATDIR= /var/cache/man/cat1
#CATDIR= /usr/man/u_man/cat1
#CATDIR= /usr/contrib/man/cat1

# extension to add on to the calc man page filename
#
# This is ignored if CATDIR is empty.
#
MANEXT= 1
#MANEXT= l

# extension to add on to the calc man page filename
#
# This is ignored if CATDIR is empty.
#
CATEXT= 1
#CATEXT= 1.gz
#CATEXT= 0
#CATEXT= l


# By default, custom builtin functions may only be executed if calc
# is given the -C option.  This is because custom builtin functions
# may invoke non-standard or non-portable code.  One may completely
# disable custom builtin functions by not compiling any custom code
#
# ALLOW_CUSTOM= -DCUSTOM	# allow custom only if -C is given
# ALLOW_CUSTOM= -UCUSTOM	# disable custom even if -C is given
#
# If in doubt, use ALLOW_CUSTOM= -DCUSTOM
#
ALLOW_CUSTOM= -DCUSTOM
#ALLOW_CUSTOM= -UCUSTOM

# If the $CALCPATH environment variable is not defined, then the following
# path will be searched for calc resource file routines.
#
ifeq ($(ALLOW_CUSTOM),-DCUSTOM)
CALCPATH= .:./cal:~/.cal:${T}${CALC_SHAREDIR}:${T}${CUSTOMCALDIR}
else	# ($(ALLOW_CUSTOM),-DCUSTOM)
CALCPATH= .:./cal:~/.cal:${T}${CALC_SHAREDIR}
endif	# ($(ALLOW_CUSTOM),-DCUSTOM)

# When RPM_TOP is defined, we do not use ${T}
#
ifdef RPM_TOP
ifeq ($(ALLOW_CUSTOM),-DCUSTOM)
CALCPATH:= .:./cal:~/.cal:${CALC_SHAREDIR}:${CUSTOMCALDIR}
else	# ($(ALLOW_CUSTOM),-DCUSTOM)
CALCPATH:= .:./cal:~/.cal:${CALC_SHAREDIR}
endif	# ($(ALLOW_CUSTOM),-DCUSTOM)
endif	# RPM_TOP

# If the $CALCRC environment variable is not defined, then the following
# path will be searched for calc resource files.
#
CALCRC= ./.calcinit:~/.calcrc:${CALC_SHAREDIR}/startup
#CALCRC= ./.calcinit;~/.calcrc;${CALC_SHAREDIR}/startup

# Determine of the GNU-readline facility will be used instead of the
# builtin calc binding method.
#
# USE_READLINE=			    Do not use GNU-readline, use calc bindings
# USE_READLINE= -DUSE_READLINE	    Use GNU-readline, do not use calc bindings
#
# NOTE: If you select the 'USE_READLINE= -DUSE_READLINE' mode, you must set:
#
#	READLINE_LIB		The flags needed to link in the readline
#				and history link libraries
#	READLINE_EXTRAS		Flags and libs needed to use the readline
#				and history link libraries
#	READLINE_INCLUDE	Where the readline include files reside
#				(leave blank if they are /usr/include/readline)
#
# NOTE: If you select the 'USE_READLINE=' mode, then we recommend you set:
#
#	READLINE_EXTRAS=
#	READLINE_INCLUDE=
#	READLINE_LIB=
#
# NOTE: The GNU-readline code is not shipped with calc.  You must have
#	the appropriate headers and link libs installed on your system in
#	order to use it.
#
# To disable the use of the GNU-readline facility (as well as ncurses), set:
#
#	USE_READLINE=
#	READLINE_EXTRAS=
#	READLINE_INCLUDE=
#	READLINE_LIB=
#
# If in doubt, set USE_READLINE, READLINE_EXTRAS, READLINE_INCLUDE, and
# READLINE_LIB to nothing.
#
#USE_READLINE=
USE_READLINE= -DUSE_READLINE
#
#READLINE_LIB=
#READLINE_EXTRAS=
#
READLINE_LIB= -lreadline
READLINE_EXTRAS= -lhistory -lncurses
#
#READLINE_LIB= -L/usr/gnu/lib -lreadline
#READLINE_EXTRAS= -lhistory -lncurses
#
#READLINE_LIB= -L${PREFIX}/lib -lreadline
#READLINE_EXTRAS= -lhistory -lncurses
#
# For Apple OS X: install fink from http://fink.sourceforge.net
#		  and then do a 'fink install readline' and then use:
#
#READLINE_LIB= -L/sw/lib -lreadline
#READLINE_EXTRAS= -lhistory -lncurses
#
# For Apple OS X: install HomeBrew and then:
#
#	brew install readline
#
# and use:
#
#READLINE_LIB= -L${PREFIX}/opt/readline/lib -lreadline
#READLINE_EXTRAS= -lhistory -lncurses
#
READLINE_INCLUDE=
#READLINE_INCLUDE= -I/usr/gnu/include
#READLINE_INCLUDE= -I${PREFIX}/include

# Handle the case where macOS is being used with HomeBrew
# # and using the readline, history, and ncurses libraries.
# #
ifneq ($(HOMEBREW_PREFIX),)
READLINE_LIB:= -L${HOMEBREW_PREFIX}/opt/readline/lib -lreadline
READLINE_INCLUDE:= -I${HOMEBREW_PREFIX}/opt/readline/include
endif	# ($(HOMEBREW_PREFIX),)

# If $PAGER is not set, use this program to display a help file
#
#CALCPAGER= more
#CALCPAGER= pg
#CALCPAGER= cat
CALCPAGER= less
#CALCPAGER= less.exe -ci

# Debug/Optimize options for ${CC} and ${LCC}
#
#DEBUG=
#DEBUG= -g
#DEBUG= -g3
#
#DEBUG= -O
#DEBUG= -O -g
#DEBUG= -O -g3
#
#DEBUG= -O1
#DEBUG= -O1 -g
#DEBUG= -O1 -g3
#
#DEBUG= -O2
#DEBUG= -O2 -g
#DEBUG= -O2 -g3
#DEBUG= -O2 -ipa
#DEBUG= -O2 -g3 -ipa
#
#DEBUG= -O3
#DEBUG= -O3 -g
DEBUG= -O3 -g3
#DEBUG= -O3 -ipa
#DEBUG= -O3 -g3 -ipa

# Some systems require one to use ranlib to add a symbol table to
# a *.a link library.  Set RANLIB to the utility that performs this
# action.  Set RANLIB to : if your system does not need such a utility.
#
RANLIB=ranlib
#RANLIB=:

# If you do not wish to use purify, set PURIFY to an empty string.
#
# If in doubt, use PURIFY=
#
#PURIFY= purify
#PURIFY= purify -m71-engine
#PURIFY= purify -logfile=pure.out
#PURIFY= purify -m71-engine -logfile=pure.out


PURIFY=

# If you want to use a debugging link library such as a malloc debug link
# library, or need to add special ld flags after the calc link libraries
# are included, set ${LD_DEBUG} below.
#
# If in doubt, set LD_DEBUG to empty.
#
#LD_DEBUG= -lmalloc_cv
LD_DEBUG=

# Environment variables for local directory calc execution and local directory calc testing
#
# These environment variables are used in the following rules:
#
#	make check
#	make chk
#	make debug
#	make testfuncsort
#	make prep
#	make run
#
# NOTE: An equivalent environment variable setting is found in .lldbinit for lldb use.
#
# When calc is installed on the local system, it is assumed that variables such as
# ${LIBDIR} will be set to the default LD_LIBRARY_PATH for the system.  Thus for
# normal execution outside of the special rules mentioned in this comment block,
# the system wide defaults for shared libraries will be used AND that one does NOT
# need to use set these environment variables for normal calc use.
#
ifeq ($(ALLOW_CUSTOM),-DCUSTOM)
CALC_ENV= CALCPATH=./cal LD_LIBRARY_PATH=. DYLD_LIBRARY_PATH=. CALCHELP=./help \
	  CALCCUSTOMHELP=./custom
else	# ($(ALLOW_CUSTOM),-DCUSTOM)
CALC_ENV= CALCPATH=./cal LD_LIBRARY_PATH=. DYLD_LIBRARY_PATH=. CALCHELP=./help
endif	# ($(ALLOW_CUSTOM),-DCUSTOM)

# Some out of date operating systems require/want an executable to
# end with a certain file extension.  Some compiler systems such as
# Windows build calc as calc.exe.  The EXT variable is used to denote
# the extension required by such.  Note that Cygwin requires EXT to be
# the same as Linux/Un*x/GNU, even though it runs under Windows.
#
# EXT=				# normal Un*x / Linux / GNU/Linux / Cygwin
# EXT=.exe			# Windows
#
# If in doubt, use EXT=
#
EXT=
#EXT=.exe

# The calc version in the form of x.y.z.w
#
VERSION= 2.15.0.7

# The calc major version in the form of x.y.z
#
VER= 2.15.0

# Names of shared libraries with versions
#
LIB_EXT= .so
LIB_EXT_VERSION= ${LIB_EXT}.${VERSION}
LIB_EXT_VER= ${LIB_EXT}.${VER}

# standard utilities used during make
#
AR= ar
AWK= awk
CAT= cat
CHMOD= chmod
CMP= cmp
CO= co
CP= cp
CTAGS= ctags
DATE= date
DIFF= diff
FMT= fmt
GREP= grep
GZIP= gzip
HOSTNAME= hostname
LANG= C
LDCONFIG= ldconfig
LN= ln
LS= ls
MAKE= make
MAKEDEPEND= makedepend
MAN= man
MKDIR= mkdir
MV= mv
PWDCMD= pwd
RM= rm
RMDIR= rmdir
SDIFF= sdiff
SED= sed
SORT= sort
SPLINT= splint
SPLINT_OPTS=
STRIP= strip
TAIL= tail
TEE= tee
TOUCH= touch
TRUE= true
UNAME= uname
XARGS= xargs

# NOTE: On some shells, echo is a builtin that does
#	not understand -n, so we call /bin/echo -n
#	directly to get around such shells.
#
ECHON= /bin/echo -n

# Extra compiling and linking flags
#
# EXTRA_CFLAGS are flags given to ${CC} when compiling C files
# EXTRA_LDFLAGS are flags given to ${CC} when linking programs
#
# Both CFLAGS and LDFLAGS are left blank in this Makefile by
# default so that users may use them on the make command line
# to always set the way that C is compiled and files are linked
# respectively.  For example:
#
#	make all EXTRA_CFLAGS="-DMAGIC" EXTRA_LDFLAGS="-lmagic"
#
# NOTE: These should be left blank in this Makefile to make it
#       easier to add stuff on the command line.  If you want to
#	to change the way calc is compiled by this Makefile, change
#	the appropriate host target section below or a flag above.
#
EXTRA_CFLAGS=
EXTRA_LDFLAGS=

# Architecture compile flags
#
# The ARCH_CFLAGS are ${CC} when compiling C files. They follow
# CCMISC and precede EXTRA_CFLAGS.
#
# When ARCH_CFLAGS is empty, the native binary architecture is assumed.
#
ARCH_CFLAGS=
# ARCH_CFLAGS= -arch i386		# old Intel binary
# ARCH_CFLAGS= -arch ppc		# Power PC binary
# ARCH_CFLAGS= -arch x86_64		# Intel 64-bit binary
# ARCH_CFLAGS= -arch arm64		# Apple Silicon binary
# ARCH_CFLAGS= -arch arm64 -arch x86_64	# Apple Silicon and Intel 64-bit binary
# ARCH_CFLAGS= -arch i386 -arch ppc	# old Intel and Power PC binary

# COMMON_CFLAGS are the common ${CC} flags used for all programs, both
#	    intermediate and final calc and calc related programs
#
ifeq ($(ALLOW_CUSTOM),-DCUSTOM)
COMMON_CFLAGS= -DCALC_SRC ${ALLOW_CUSTOM} ${CCWARN} ${CCMISC} ${ARCH_CFLAGS} ${EXTRA_CFLAGS}
else	# ($(ALLOW_CUSTOM),-DCUSTOM)
COMMON_CFLAGS= -DCALC_SRC -UCUSTOM ${CCWARN} ${CCMISC} ${ARCH_CFLAGS} ${EXTRA_CFLAGS}
endif	# ($(ALLOW_CUSTOM),-DCUSTOM)

# COMMON_LDFLAGS are the common flags used for linking all programs, both
#	     intermediate and final calc and calc related programs
#
COMMON_LDFLAGS= ${EXTRA_LDFLAGS}

# Common Address Sanitizer (ASAN)
#
# For more info see: https://github.com/google/sanitizers/wiki/AddressSanitizer
# See also: https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early
#
# The following Address Sanitizer (ASAN) are common to both REHL9.2 (Linux) and macOS 14.0.
#
# By default, the Address Sanitizer is NOT enabled, not compiled into calc.
# To enable the Address Sanitizer, uncomment the appropriate lines in Makefile.local !!!
#
FSANITIZE:= -Wno-invalid-command-line-argument
FSANITIZE+= -fsanitize=address
FSANITIZE+= -fsanitize=alignment
FSANITIZE+= -fsanitize=bool
FSANITIZE+= -fsanitize=enum
FSANITIZE+= -fsanitize=vptr
FSANITIZE+= -fsanitize=integer-divide-by-zero
FSANITIZE+= -fsanitize=float-divide-by-zero
FSANITIZE+= -fsanitize=float-cast-overflow
FSANITIZE+= -fsanitize=nonnull-attribute
FSANITIZE+= -fsanitize=returns-nonnull-attribute
FSANITIZE+= -fsanitize=null
FSANITIZE+= -fsanitize=object-size
FSANITIZE+= -fsanitize=shift
FSANITIZE+= -fsanitize=signed-integer-overflow
FSANITIZE+= -fsanitize=undefined
FSANITIZE+= -fsanitize=unreachable
FSANITIZE+= -fsanitize=vla-bound
FSANITIZE+= -fno-omit-frame-pointer
FSANITIZE+= -fno-common
